{-# LANGUAGE GeneralisedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}

module VscExtFetcher (VscExtension (..), runFetcher, getVscExts) where

import Codec.Archive.Zip
import Control.Exception
import Control.Monad.Except
import Data.Aeson
import Data.Aeson.Types (parse)
import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy as LBS
import Data.Hashable
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Builder as LTB
import Network.HTTP.Req
import qualified Paths_vscext_fetcher as Ver
import System.Console.ANSI
import System.Directory
import System.Exit
import System.FilePath
import System.Posix.Temp (mkdtemp)
import System.Process
import Terminal

data VscExtension = VscExt
  { publisher, name, version :: Text
  }
  deriving (Show, Eq)

instance Hashable VscExtension where
  hashWithSalt s v = hashWithSalt s (publisher v, name v, version v)

extensionId :: VscExtension -> String
extensionId e = T.unpack (T.concat [publisher e, ".", name e, "-", version e])

newtype Fetcher a = Fetcher (ExceptT String IO a)
  deriving (Functor, Applicative, Monad, MonadIO, MonadError String)

instance MonadHttp Fetcher where
  getHttpConfig = return defaultHttpConfig
  handleHttpException e = throwError ("failed to fetch file:\n" ++ show e)

runFetcher :: Fetcher a -> IO (Either String a)
runFetcher (Fetcher f) = runExceptT f

fetchVscMarketplace :: VscExtension -> Fetcher ByteString
fetchVscMarketplace e =
  responseBody
    <$> req
      GET
      (https (T.append (publisher e) ".gallery.vsassets.io") /: "_apis" /: "public" /: "gallery" /: "publisher" /: publisher e /: "extension" /: name e /: version e /: "assetbyname" /: "Microsoft.VisualStudio.Services.VSIXPackage")
      NoReqBody
      lbsResponse
      mempty

getVersion :: ByteString -> Either String Text
getVersion ext =
  toArchiveOrFail ext
    >>= toEither "extension/package.json not found"
      . findEntryByPath "extension/package.json"
    >>= (toEither "Failed to parse package.json to json value" . decode) . fromEntry
    >>= ( \case
            Success v -> Right v
            Error e -> Left e
        )
      . parse (.: "version")
  where
    toEither e m =
      case m of
        Just v -> Right v
        Nothing -> Left e

getHash :: String -> ByteString -> Fetcher Text
getHash eid ext =
  liftIO
    ( mkdtemp ("/tmp" </> eid) >>= \dir ->
        ( let path = dir </> eid <.> "vsix"
           in LBS.writeFile path ext
                >> readProcessWithExitCode
                  "nix-hash"
                  ["--flat", "--base32", "--type", "sha256", path]
                  ""
        )
          `finally` removeDirectoryRecursive dir
    )
    >>= \(exit, dat, err) ->
      liftEither
        ( case (err, exit) of
            ("", ExitSuccess) -> Right (T.pack (head (words dat)))
            ("", ExitFailure e) -> Left ("nix-hash returns " ++ show e)
            (e, _) -> Left ("nix-hash failed with message:\n" ++ e)
        )

toNix :: VscExtension -> Text -> [LTB.Builder]
toNix e hsh =
  [ "{\n",
    field "name" (name e),
    field "publisher" (publisher e),
    field "version" (version e),
    field "sha256" hsh,
    "};\n"
  ]
  where
    field n v = "  " <> n <> " = \"" <> LTB.fromText v <> "\";\n"

toNixFile :: [(VscExtension, Text)] -> LT.Text
toNixFile b =
  LTB.toLazyText
    ( mconcat
        [ "# generated by vscext-fetcher " <> LTB.fromString (show Ver.version) <> "\n",
          "{ vscode-utils }: {\n",
          foldr
            ( \(e, hsh) acc ->
                let obj = toNix e hsh
                 in foldr
                      (\v ac -> "  " <> v <> ac)
                      acc
                      ( mconcat [LTB.fromText (publisher e), ".", LTB.fromText (name e), " = vscode-utils.extensionFromVscodeMarketplace ", head obj]
                          : tail obj
                      )
            )
            mempty
            b,
          "}"
        ]
    )

getVscExts :: [VscExtension] -> Fetcher LT.Text
getVscExts exts =
  toNixFile
    <$> traverse
      ( \e -> do
          let eid = extensionId e
          liftIO $ withColor Cyan (putStrLn ("[~] getting " ++ eid))

          liftIO $ putStrLn "fetching vsix from vscode marketplace"
          bin <- fetchVscMarketplace e

          ver <-
            if version e /= "latest"
              then return (version e)
              else
                liftIO (putStrLn "reading extension version")
                  >> liftEither (getVersion bin)

          liftIO $ putStrLn "hashing vsix"
          hsh <- getHash eid bin

          liftIO $ withColor Green (putStrLn ("[-] " ++ eid ++ " complete"))
          return (e {version = ver}, hsh)
      )
      exts